<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vscode 必备插件</title>
      <link href="/2021/07/05/vscode-bi-bei-cha-jian/"/>
      <url>/2021/07/05/vscode-bi-bei-cha-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="插件安装步骤"><a href="#插件安装步骤" class="headerlink" title="插件安装步骤"></a>插件安装步骤</h2><p><img src="/2021/07/05/vscode-bi-bei-cha-jian/1.png"></p><h2 id="1-local-history"><a href="#1-local-history" class="headerlink" title="1. local history"></a>1. local history</h2><blockquote><p>修改代码之后想找回历史代码怎么办？<br>&emsp;&emsp;在使用Pycharm、IDEA时可以直接查看本地历史代码，然后轻松恢复之前某个版本。但是，VS Code默认是不支持<strong>local history</strong>的，所以，&gt;仅凭<strong>Ctrl+z</strong>撤销操作时不行的。<br>&emsp;&emsp;安装这款插件之后在侧边栏会出现<strong>LOCAL HISTORY</strong>的字样，每当我们保存更改时，它都会备份一份历史文件，当我们需要恢复之前版本时，只需要点击一下对应的文件即可。此外，它还会在编辑框显示对比详情，能够让你对修改位置一目了然。</p></blockquote><h2 id="2-vscode-icons"><a href="#2-vscode-icons" class="headerlink" title="2. vscode-icons"></a>2. vscode-icons</h2><blockquote><p>&emsp;&emsp;一个好的编辑界面能够让开发过程心情舒畅，甚至可以提升开发效率。显然，VS Code默认的图标是达不到这种程度的。但是，配合<strong>vscode-icons</strong>这款插件就不同了，它具有以下特性，</p></blockquote><ul><li>自定义图标</li><li>自动检测项目</li><li>自定义配置</li></ul><blockquote><p>&emsp;&emsp;它不仅能够给文件夹、文件添加上舒适的图标，而且可以自动检测项目，根据项目不同功能配上不同图标，例如，git、Markdown、配置项、工具类等等。</p></blockquote><h2 id="3-Bracket-Pair-Colorizer"><a href="#3-Bracket-Pair-Colorizer" class="headerlink" title="3. Bracket Pair Colorizer"></a>3. Bracket Pair Colorizer</h2><blockquote><p>&emsp;&emsp;当你看到上述示例中这样包含多层嵌套的括号时，是不是觉得很凌乱？至少，我是这样的，每当看到这样复杂嵌套括号时，尤其代码行数多起来以后，就很难确定哪些是处于同一层次的。不弄明白层次结构，当然阅读代码也会麻烦很多。</p></blockquote><blockquote><p>&emsp;&emsp;<strong>Bracket Pair Colorizer</strong>这款插件可以给<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>这些常用括号显示不同颜色，当点击对应括号时能够用线段直接链接到一起，让层次结构一目了然。除此之外，它还支持用户自定义符号。</p></blockquote><h2 id="4-Auto-Close-Tag"><a href="#4-Auto-Close-Tag" class="headerlink" title="4.Auto Close Tag"></a>4.Auto Close Tag</h2><blockquote><p>自动闭合HTML/XML标签</p></blockquote><h2 id="5-Auto-Rename-Tag"><a href="#5-Auto-Rename-Tag" class="headerlink" title="5.Auto Rename Tag"></a>5.Auto Rename Tag</h2><blockquote><p>自动完成另一侧标签的同步修改</p></blockquote><h2 id="6-中文（简体）语言包——-Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#6-中文（简体）语言包——-Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="6.中文（简体）语言包—— Chinese (Simplified) Language Pack for Visual Studio Code"></a>6.中文（简体）语言包—— Chinese (Simplified) Language Pack for Visual Studio Code</h2><blockquote><p>将编译器转成中文模式</p></blockquote><h2 id="7-Vetur"><a href="#7-Vetur" class="headerlink" title="7.Vetur"></a>7.Vetur</h2><blockquote><p>&emsp;&emsp;Vue多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。vscode官方钦定Vue插件，Vue开发者必备。</p></blockquote><h2 id="8-Markdown-Preview-Enhanced"><a href="#8-Markdown-Preview-Enhanced" class="headerlink" title="8.Markdown Preview Enhanced"></a>8.Markdown Preview Enhanced</h2><blockquote><p>实时预览markdown，markdown使用者必备</p></blockquote><p><img src="/2021/07/05/vscode-bi-bei-cha-jian/0.png"></p>]]></content>
      
      
      <categories>
          
          <category> Vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题（一）</title>
      <link href="/2021/07/04/qian-duan-mian-shi-ti-yi/"/>
      <url>/2021/07/04/qian-duan-mian-shi-ti-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="1、css盒模型有哪些要素"><a href="#1、css盒模型有哪些要素" class="headerlink" title="1、css盒模型有哪些要素"></a>1、css盒模型有哪些要素</h2><p>&emsp;- 内容区（content）<br>&emsp;- 内边距（padding）<br>&emsp;- 边框（border）<br>&emsp;- 外边距（margin）</p><h2 id="2、css的伪类选择符有哪些"><a href="#2、css的伪类选择符有哪些" class="headerlink" title="2、css的伪类选择符有哪些"></a>2、css的伪类选择符有哪些</h2><h4 id="一、和元素本身状态有关"><a href="#一、和元素本身状态有关" class="headerlink" title="一、和元素本身状态有关"></a>一、和元素本身状态有关</h4><p>&emsp;&emsp;:link指的是超链接在访问前的状态<br>&emsp;&emsp;:visited指的是超链接在访问后的转态<br>&emsp;&emsp;:hover指的是鼠标悬停在元素上的状态<br>&emsp;&emsp;:active指的是鼠标点击元素不放时的转态</p><p>&emsp;&emsp;这几个伪类的书写有一定的顺序，:link和:visited的状态表示的是一个静态的状态，即链接要么就是被激活过，要么就是没激活过，激活后的css属性如果与激活前冲突，则覆盖激活前的属性；而:hover和:active是动作属性，设置这样的伪类css的目的就是为了使得执行相应动作时能够显示相应的状态，也就是希望属性冲突时，覆盖静态属性。因此:hover和:active伪类要写在后面从而覆盖静态属性，而:active又是在:hover基础上的动作，因此，:hover在:active之前。<br>&emsp;&emsp;正常顺序是::link :visited :hover :active</p><p>&emsp;&emsp;:focus设置对象在成为输入焦点（该对象的onfocus事件发生）时的样式。<br>&emsp;&emsp;:empty匹配没有任何子元素（包括text节点）的元素<br>&emsp;&emsp;:checked匹配用户界面上处于选中状态的元素(用于input type为radio与checkbox时)<br>&emsp;&emsp;:enabled匹配用户界面上处于可用状态的元素<br>&emsp;&emsp;:disabled匹配用户界面上处于禁用状态的元素<br>&emsp;&emsp;:target匹配相关URL指向的元素<br>&emsp;&emsp;这些伪类都不太常用，需要可以查询使用。</p><h4 id="二、和元素在DOM结构中所处的位置有关"><a href="#二、和元素在DOM结构中所处的位置有关" class="headerlink" title="二、和元素在DOM结构中所处的位置有关"></a>二、和元素在DOM结构中所处的位置有关</h4><p>&emsp;&emsp;child类型：作为孩子该满足的条件<br>&emsp;&emsp;:first-child: 元素得是其父元素的第一个子元素才匹配<br>&emsp;&emsp;:last-child: 元素得是其父元素的最后一个子元素才匹配<br>&emsp;&emsp;:nth-child(n): 元素得是其父元素的第n个子元素才匹配<br>&emsp;&emsp;:nth-last-child(n): 元素得是其父元素的倒数第n个子元素才匹配<br>&emsp;&emsp;:only-child: 元素得是其父元素的唯一一个子元素才匹配<br>&emsp;&emsp;of-type类型：作为同类元素的兄弟该满足的条件<br>&emsp;&emsp;:first-of-type: 元素得是其父元素的第一个该类元素才匹配<br>&emsp;&emsp;:last-of-type: 元素得是其父元素的最后一个该类元素才匹配<br>&emsp;&emsp;:only-of-type: 元素得是其父元素的唯一一个该类元素才匹配<br>&emsp;&emsp;:nth-of-type(n): 元素得是其父元素的第n个该类元素才匹配<br>&emsp;&emsp;:nth-last-of-type(n): 元素得是其父元素的倒数第n个子元素才匹配其他<br>&emsp;&emsp;not: 排除元素<br>&emsp;&emsp;例： li:not(:first-child): 元素不是其父元素的第一个子元素的li元素被匹配</p><h2 id="3、请简单描述一下flex弹性盒子的特点"><a href="#3、请简单描述一下flex弹性盒子的特点" class="headerlink" title="3、请简单描述一下flex弹性盒子的特点"></a>3、请简单描述一下flex弹性盒子的特点</h2><p>&emsp;&emsp;flex布局  简单、快速、高效页面布局</p><h2 id="4、请简单描述display属性中inline、block和inline-block的特点"><a href="#4、请简单描述display属性中inline、block和inline-block的特点" class="headerlink" title="4、请简单描述display属性中inline、block和inline-block的特点"></a>4、请简单描述display属性中inline、block和inline-block的特点</h2><h4 id="display-block的特点："><a href="#display-block的特点：" class="headerlink" title="display:block的特点："></a>display:block的特点：</h4><p>&emsp;&emsp;1、block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。<br>&emsp;&emsp;2、block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。<br>&emsp;&emsp;3、block元素可以设置margin和padding属性。</p><h4 id="display-inline的特点："><a href="#display-inline的特点：" class="headerlink" title="display:inline的特点："></a>display:inline的特点：</h4><p>&emsp;&emsp;1、inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。<br>&emsp;&emsp;2、inline元素设置width,height属性无效。<br>&emsp;&emsp;3、inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</p><h4 id="display-inline-block的特点：同时具有inline和block的特点"><a href="#display-inline-block的特点：同时具有inline和block的特点" class="headerlink" title="display:inline-block的特点：同时具有inline和block的特点"></a>display:inline-block的特点：同时具有inline和block的特点</h4><h2 id="5、请简单描述position属性中fixed、relative和absolute的特点"><a href="#5、请简单描述position属性中fixed、relative和absolute的特点" class="headerlink" title="5、请简单描述position属性中fixed、relative和absolute的特点"></a>5、请简单描述position属性中fixed、relative和absolute的特点</h2><p>&emsp;&emsp;（1）relative（相对定位）：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。　　<br>&emsp;&emsp;（2）absolute（绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。<br>&emsp;&emsp;（3）fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。<br>static与fixed的定位方式较好理解，在此不做分析。下面对应用的较多的relative和absolute进行分析：</p><h2 id="6、请简单描述box-sizing属性中content-box和border-box的特点"><a href="#6、请简单描述box-sizing属性中content-box和border-box的特点" class="headerlink" title="6、请简单描述box-sizing属性中content-box和border-box的特点"></a>6、请简单描述box-sizing属性中content-box和border-box的特点</h2><h4 id="正常盒模型"><a href="#正常盒模型" class="headerlink" title="正常盒模型"></a>正常盒模型</h4><p>&emsp;&emsp;正常盒模型，是指块元素box-sizing属性为content-box的盒模型。一般在现代浏览器中使用的都是正常盒模型content-box，它也是标准 w3c 盒子模型。<br>&emsp;&emsp;正常盒模型是指：盒模型的大小包括content，padding，border，并且先做content.。<br>&emsp;&emsp;正常盒模型的大小会以内容优先自动扩展，内部子元素超过父元素给定的大小，会将父元素撑大。</p><h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h4><p>&emsp;&emsp;怪异盒模型，是指块元素box-sizing属性为border-box的盒模型。一般在IE浏览器中默认为这种怪异盒模型，但是由于其自身的特殊性，手机页面中也有使用怪异盒模型。<br>&emsp;&emsp;怪异盒模型是先做盒。然后添加border，padding，最后做content。即保证盒模型优先，先做盒再放内容，不管内容是否放得下，一般手机上用的更多。<br>&emsp;&emsp;更通俗的说，怪异盒模型中，父元素的盒模型确定，子元素是无法撑开父元素的盒模型，只能在盒模型剩余空间展示。</p><h2 id="7、typeof的返回值有哪些"><a href="#7、typeof的返回值有哪些" class="headerlink" title="7、typeof的返回值有哪些"></a>7、typeof的返回值有哪些</h2><h4 id="基本类型："><a href="#基本类型：" class="headerlink" title="基本类型："></a>基本类型：</h4><p>&emsp;&emsp;number<br>&emsp;&emsp;string<br>&emsp;&emsp;Boolean<br>&emsp;&emsp;null<br>&emsp;&emsp;undefined</p><h4 id="复杂类型："><a href="#复杂类型：" class="headerlink" title="复杂类型："></a>复杂类型：</h4><p>&emsp;&emsp;object<br>&emsp;&emsp;typeof返回值也有六种，分别是：<br>&emsp;&emsp;number<br>&emsp;&emsp;string<br>&emsp;&emsp;Boolean<br>&emsp;&emsp;object<br>&emsp;&emsp;undefined<br>&emsp;&emsp;function</p><h2 id="8、请简单描述-与-的区别"><a href="#8、请简单描述-与-的区别" class="headerlink" title="8、请简单描述== 与 === 的区别"></a>8、请简单描述== 与 === 的区别</h2><h4 id="双等号-："><a href="#双等号-：" class="headerlink" title="双等号==："></a>双等号==：</h4><p>　　（1）如果两个值类型相同，再进行三个等号(===)的比较</p><p>　　（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p><p>　　　　（1）如果一个是null，一个是undefined，那么相等</p><p>　　　　（2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较</p><h4 id="三等号"><a href="#三等号" class="headerlink" title="三等号===:"></a>三等号===:</h4><p>　　（1）如果类型不同，就一定不相等</p><p>　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）</p><p>　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p><p>　　（4）如果两个值都是true，或是false，那么相等</p><p>　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p><p>　　（6）如果两个值都是null，或是undefined，那么相等</p><h2 id="9、请简单描述js中var和let的特点"><a href="#9、请简单描述js中var和let的特点" class="headerlink" title="9、请简单描述js中var和let的特点"></a>9、请简单描述js中var和let的特点</h2><p>&emsp;&emsp;ES6 新增了let命令，用来声明局部变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效，而且有暂时性死区的约束。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>&emsp;&emsp;使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象<br>&emsp;&emsp;使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升<br>&emsp;&emsp;let不允许在相同作用域内，重复声明同一个变量<br>&emsp;&emsp;let 配合for循环的独特应用<br>&emsp;&emsp;let非常适合用于 for循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。例如：</p><pre class="line-numbers language-none"><code class="language-none">for (var i &#x3D; 0; i &lt;10; i++) &#123;    setTimeout(function() &#123;  &#x2F;&#x2F; 同步注册回调函数到 异步的 宏任务队列。    console.log(i);        &#x2F;&#x2F; 执行此代码时，同步代码for循环已经执行完成  &#125;, 0);&#125;&#x2F;&#x2F; 输出结果10    10    10    10    10    10    10    10    10    10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当我们将var改为let：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。for (let i &#x3D; 0; i &lt; 10; i++) &#123;   setTimeout(function() &#123;    console.log(i);    &#x2F;&#x2F;  i 是循环体内局部作用域，不受外界影响。  &#125;, 0);&#125;&#x2F;&#x2F; 输出结果：0  1  2  3  4  5  6  7  8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>let没有变量提升与暂时性死区</strong><br>&emsp;&emsp;ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。用let声明的变量，不存在变量提升。而且要求必须等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误</p><p><strong>let变量不能重复声明</strong><br>&emsp;&emsp;let不允许在相同作用域内，重复声明同一个变量。否则报错：Uncaught SyntaxError: Identifier ‘XXX’ has already been declared</p><pre class="line-numbers language-none"><code class="language-none">var a &#x3D; 1;var a &#x3D; 2;&#x2F;&#x2F;不会报错let b &#x3D; 1;let b &#x3D; 2;&#x2F;&#x2F;报错:Uncaught SyntaxError: Identifier &#39;XXX&#39; has already been declared<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>const声明的特点</strong><br>&emsp;&emsp;可以理解为，let的特性const都有，不能反复声明，存在块级作用域，不存在变量提升，也有暂时性死域的特点。与let区别在于，const声明的是一个常量，一旦声明就无法修改</p><pre class="line-numbers language-none"><code class="language-none">const a &#x3D; &#123;&#125;;a.b &#x3D; 1;console.log(a);&#x2F;&#x2F;&#123;b:1&#125;const声明的变量并非变量的值不能修改，而是可以理解为变量的指向不能修改，所以这里不会出错a &#x3D; [];&#x2F;&#x2F;这里直接修改了变量a的指向。console.log(a);&#x2F;&#x2F;报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10、请简单描述js中数组和对象的区别"><a href="#10、请简单描述js中数组和对象的区别" class="headerlink" title="10、请简单描述js中数组和对象的区别"></a>10、请简单描述js中数组和对象的区别</h2><h4 id="区别一："><a href="#区别一：" class="headerlink" title="区别一："></a>区别一：</h4><p>​          数组是有序数据的集合，而对象是无序数据的集合。</p><h4 id="区别二："><a href="#区别二：" class="headerlink" title="区别二："></a>区别二：</h4><p>​          数组的数据没有名称，只有下标，而对象的数据需要指定名称。</p><h2 id="11、请写一段代码，输出200以内，所有既能整除3又能整除5的数。"><a href="#11、请写一段代码，输出200以内，所有既能整除3又能整除5的数。" class="headerlink" title="11、请写一段代码，输出200以内，所有既能整除3又能整除5的数。"></a>11、请写一段代码，输出200以内，所有既能整除3又能整除5的数。</h2>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> JS </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习路线</title>
      <link href="/2021/07/03/qian-duan-xue-xi-lu-xian/"/>
      <url>/2021/07/03/qian-duan-xue-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTML5-CSS3"><a href="#1-HTML5-CSS3" class="headerlink" title="1.HTML5 + CSS3"></a>1.HTML5 + CSS3</h2><p>&emsp;&emsp;根据web前端发展史，建议大家先学习pc端页面开发。 包含： HTML5、CSS3、浮动、定位、盒子模型、高级技巧等等。 不用说，这是我们前端入门的最基本要求，目的是能完成页面的布局开发，这部分必须精通。 这部分知识比较简单， 不要去买书看了（太浪费时间），直接看pink老师视频就够了哈。</p><h4 id="视频地址：https-www-bilibili-com-video-av80149248"><a href="#视频地址：https-www-bilibili-com-video-av80149248" class="headerlink" title="视频地址：https://www.bilibili.com/video/av80149248"></a>视频地址：<a href="https://www.bilibili.com/video/av80149248">https://www.bilibili.com/video/av80149248</a></h4><h2 id="2-移动端页面开发"><a href="#2-移动端页面开发" class="headerlink" title="2.移动端页面开发"></a>2.移动端页面开发</h2><p>&emsp;&emsp;我们先学习了pc端页面开发，但是现在移动端太常见了，所以我们也需要做移动端页面开发。 主要学习移动端常见布局：流失布局、flex布局、rem布局、响应式布局等。 其中市场rem布局用的最多了，重点掌握。 网上相应的布局视频很多，可以重点学习。 最终起码把几个大厂的移动端首页写出来才可以。比如淘宝、京东、小米等。</p><h2 id="3-JavaScript-系列"><a href="#3-JavaScript-系列" class="headerlink" title="3.JavaScript 系列"></a>3.JavaScript 系列</h2><p>&emsp;&emsp;JavaScript是我们前端的核心，需要精通掌握，可以直接学习ES5，ES6就可以了。这样就可以让我们页面交互效果动态展示起来了。 包含： JavaScript 基础语法及 Web API 开发动态交互（⽹⻚特效）的⽹⻚、JavaScript ⾼级特性，如⾯向对象、闭包、事件循环等技术、 jQuery也要了解一些，现在市场很多老项目还是大量有jQuery的，你说不会jQuery，人家不相信你前端工作过。。。</p><h4 id="学习渠道："><a href="#学习渠道：" class="headerlink" title="学习渠道："></a>学习渠道：</h4><p>&emsp;&emsp;首推B站， 还有 慕课，腾讯课堂等。搜索相关关键字即可。JavaScript 相关面试题可以去 掘金、牛客网、github 等网站。 相信我，最好的还是百度。 学到js ，你应该要有自己的 github 或者码云的账号了，里面有大量资源可以让你去查阅学习。</p><h2 id="4-Ajax-和-git"><a href="#4-Ajax-和-git" class="headerlink" title="4.Ajax 和 git"></a>4.Ajax 和 git</h2><p>&emsp;&emsp;前面我们写的所有页面都是静态的，也就是所有的数据都是假数据，实际开发的时候，数据都是从后台获取过来的，那么如何获取后台的相关数据呢？ 答案就是 ajax。<br>&emsp;&emsp;前端必备哦 。通过 Ajax 实现与服务器的通信，获取服务器提供的数 据，然后动态渲染输出，实现动态⽹⻚的开发。学习 git 版本管理⼯具， 实现企业级多⼈协同开。 学到这里，最好有个项目练习， 这样可以更好的明白动态网站是如何开发的。 现在网站都是流行前后端分离，这个阶段我们能知道如何调用后端接口。</p><h2 id="5-Node-js"><a href="#5-Node-js" class="headerlink" title="5.Node.js"></a>5.Node.js</h2><p>&emsp;&emsp;相信学ajax 的时候，很多教程搭配php或者其他后台语言来学习，但是我更推荐ajax和node来学习，毕竟都属于我们前端内容，省去在学习另外一门语言的痛苦。</p><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><p>&emsp;&emsp;通过学习 Nodejs 和 MySQL 深⼊理解⽹站的本质，以及前端在整个⽹站开发中的⻆⾊，为在企业中前后端协同开发提供帮助。体会 Nodejs 在前端⼯程化开发中的重要作⽤。</p><h2 id="6-VUE"><a href="#6-VUE" class="headerlink" title="6.VUE"></a>6.VUE</h2><p>&emsp;&emsp;前端三大框架 你肯定听过 vue 、react 、 angular。 国内最火的框架是 vue，有了这些框架，我们开发页面更加快速和高效，性能维护有了极大提高。 目的是：掌握 MVVM、模块化、组件化、状态管理、路由等技术在实战项⽬的应⽤，丰富开发经 验、提升实战能⼒，为⾼薪就业提供保障。</p><h4 id="Vue官网就非常全面：-https-cn-vuejs-org"><a href="#Vue官网就非常全面：-https-cn-vuejs-org" class="headerlink" title="Vue官网就非常全面： https://cn.vuejs.org/"></a>Vue官网就非常全面： <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></h4><p>而且b站上面也非常多的视频教程。学完开发一个pc端和移动端的网站练手。</p><h2 id="7-React"><a href="#7-React" class="headerlink" title="7.React"></a>7.React</h2><p>&emsp;&emsp;如果说vue国内最火，那么国外react是最火的，而且 现在react在国内大厂使用非常普遍，也有越来越多人选择react。</p><h2 id="8-微信小程序"><a href="#8-微信小程序" class="headerlink" title="8.微信小程序"></a>8.微信小程序</h2><p>&emsp;&emsp;小程序也能增加我们就业方向，也需要我们学习。 学习并掌握⼩程序开发的相关知识，能够独⽴完成⼩程序的开发。通过学习跨平台⼩程 序技术⽅案， 实现⼩程序的跨平台⽀持。 首推 uni-app 和 taro 来学。也是火的一塌糊涂。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2021/07/02/markdown-yu-fa/"/>
      <url>/2021/07/02/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-标题方式"><a href="#1-标题方式" class="headerlink" title="1.标题方式"></a>1.标题方式</h2><pre class="line-numbers language-none"><code class="language-none"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/07/02/markdown-yu-fa/0.png"></p><h2 id="2-段落方式"><a href="#2-段落方式" class="headerlink" title="2.段落方式"></a>2.段落方式</h2><pre class="line-numbers language-none"><code class="language-none">(1)文本末尾添加两个空格来换行(2)隔一行空行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(1)<img src="/2021/07/02/markdown-yu-fa/1.png"><br>(2)<img src="/2021/07/02/markdown-yu-fa/2.png"></p><h2 id="3-字体效果"><a href="#3-字体效果" class="headerlink" title="3.字体效果"></a>3.字体效果</h2><pre class="line-numbers language-none"><code class="language-none">（1）删除字：两个~~包裹（2）斜体字：一个*包裹（3）粗体字：两个*包裹（4）粗斜体字：三个*包裹，其实是粗体结合斜体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(1)<img src="/2021/07/02/markdown-yu-fa/3.png"><br>(2)<img src="/2021/07/02/markdown-yu-fa/4.png"><br>(3)<img src="/2021/07/02/markdown-yu-fa/5.png"><br>(4)<img src="/2021/07/02/markdown-yu-fa/6.png"></p><h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h2><pre class="line-numbers language-none"><code class="language-none">（1）3个以上的*号独占一行表示分割线，其间可以用空格隔开（2）3个以上的-号独占一行表示分割线，其间可以用空格隔开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(1)<img src="/2021/07/02/markdown-yu-fa/7.png"><br>(2)<img src="/2021/07/02/markdown-yu-fa/8.png"></p><h2 id="5-引用块"><a href="#5-引用块" class="headerlink" title="5.引用块"></a>5.引用块</h2><pre class="line-numbers language-none"><code class="language-none">（1）&gt;后接空格（2）也可以多层嵌套：&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1)<img src="/2021/07/02/markdown-yu-fa/9.png"><br>(2)<img src="/2021/07/02/markdown-yu-fa/10.png"></p><h2 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h2><h3 id="（1）有序列表"><a href="#（1）有序列表" class="headerlink" title="（1）有序列表"></a>（1）有序列表</h3><pre class="line-numbers language-none"><code class="language-none">序号 + .号后接空格1. 第一项2. 第二项3. 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/07/02/markdown-yu-fa/11.png"></p><h3 id="（2）无序列表"><a href="#（2）无序列表" class="headerlink" title="（2）无序列表"></a>（2）无序列表</h3><p><img src="/2021/07/02/markdown-yu-fa/12.png"></p><h3 id="（3）嵌套列表"><a href="#（3）嵌套列表" class="headerlink" title="（3）嵌套列表"></a>（3）嵌套列表</h3><pre class="line-numbers language-none"><code class="language-none">可以将有序列表和无序列表任意组合使用，形成嵌套模式，注意每次嵌套必须使用四个空格缩进<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/07/02/markdown-yu-fa/13.png"></p><h2 id="7-链接"><a href="#7-链接" class="headerlink" title="7.链接"></a>7.链接</h2><pre class="line-numbers language-none"><code class="language-none">（1）直接链接：&lt;&gt;内包裹链接（2）带标题的链接：在链接上悬停，会弹出标题信息（3）普通链接：[]是文字,()是链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(1)<img src="/2021/07/02/markdown-yu-fa/14.png"><br>(2)<img src="/2021/07/02/markdown-yu-fa/15.png"><br>(3)<img src="/2021/07/02/markdown-yu-fa/16.png"></p><h2 id="8-代码"><a href="#8-代码" class="headerlink" title="8.代码"></a>8.代码</h2><h3 id="（1）行内代码"><a href="#（1）行内代码" class="headerlink" title="（1）行内代码"></a>（1）行内代码</h3><pre class="line-numbers language-none"><code class="language-none">单个反引号包裹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/07/02/markdown-yu-fa/17.png"></p><h3 id="（2）代码块"><a href="#（2）代码块" class="headerlink" title="（2）代码块"></a>（2）代码块</h3><pre class="line-numbers language-none"><code class="language-none">三个反引号包裹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/07/02/markdown-yu-fa/18.png"></p><h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9.图片"></a>9.图片</h2><pre class="line-numbers language-none"><code class="language-none">格式：！[图片地址无效显示文本](图片地址 &quot;可选标题&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/07/02/markdown-yu-fa/19.png"></p><h2 id="10-表格"><a href="#10-表格" class="headerlink" title="10.表格"></a>10.表格</h2><pre class="line-numbers language-none"><code class="language-none">Markdown制作表格使用 | 来分隔不同的单元格，使用-来分隔表头和其他行对齐方式：-: 设置内容和标题栏居右对齐:- 设置内容和标题栏居左对齐:-: 设置内容和标题栏居中对齐<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/07/02/markdown-yu-fa/20.png"><br><img src="/2021/07/02/markdown-yu-fa/21.png"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
